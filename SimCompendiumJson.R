if(!require(yaml)) install.packages(yaml)
if(!require(httr)) install.packages(httr)

readDictionary <- function(dictionary, branch) {
  # given the dictionary repo name, return the whole json file for that dictionary
  #
  # Args:
  #   repo: dictionary repo name, eg: 'bpadictionary'
  #   branch: repo branch
  #
  # Returns:
  #   dictionary_nodes:  R object with two lists: 
  #      node_list: contain  dictionary nodes
  #      helper_yaml: contain information representing persistent definitions, settings and terms
  
  dict_json_path <- paste(c("https://s3.amazonaws.com/dictionary-artifacts/", dictionary , "/", branch ,"/schema.json"), collapse ="")
  dictionary_json <- fromJSON(dict_json_path)
  
  altdefs <- grep("^_", names(dictionary_json), value = TRUE)
  metaschema <- grep("metaschema.yaml", names(dictionary_json), value = TRUE)
  program <- grep("program.yaml", names(dictionary_json), value = TRUE)
  project <- grep("project.yaml", names(dictionary_json), value = TRUE)

  altdefs <- c(altdefs, metaschema, program, project)
  helper <- dictionary_json[names(dictionary_json) %in% altdefs]
  nodes <- dictionary_json[!names(dictionary_json) %in% altdefs]
  
  dictionary_nodes <- list(node_list = nodes,
                           helper_yaml = helper)
  
  return(dictionary_nodes)
  
}

## Create Node_Compendium and Compendium from Dictionary

buildCompendiums <- function(dictionary) {
  # given the raw dictionary, build a base compendium table
  # and a node relationship table to prep for simulation
  #
  # Args:
  #   dictionary: list of node links generated by the readDictionary 
  #       function
  #
  # Returns:
  #   compendiums_objects:  R object with two lists: 
  #      compendium: representing all variables in the dictionary
  #      compendium_nodes:  representing the relationship between 
  #        nodes in the dictionary
  
  # initialize empty DFs to store objects
  compendium_nodes <- data.frame(NODE = character(), 
                                 TITLE = character(),
                                 CATEGORY = character(),
                                 DESCRIPTION = character(),
                                 LINK_NAME = character(),
                                 BACKREF = character(),
                                 LABEL = character(),
                                 TARGET = character(),
                                 MULTIPLICITY = character(), 
                                 LINK_REQUIRED = character()) 
  compendium <- data.frame(DESCRIPTION = character(),
                           NODE = character(),
                           VARIABLE = character(),
                           REQUIRED = logical(), 
                           TYPE = character(),
                           CHOICES = character(), 
                           TEMPCHOICES = numeric(),
                           MAX = numeric(),
                           MIN = numeric())
  
  # get objects from dictionary
  node_list <- dictionary$node_list
  
  # loop through nodes to generate rows in compendium
  # and compendium nodes
  for (node in node_list) {
      
      # get node relationships/links
      if (nrow(node$links) > 1){
          links <- node$links[node$links$required,]
      }
      else{
          links <- node$links
      }
    
      # get compendium_nodes field definitions
      if ('name' %in% names(links) && !is.na(links$name)) {
          # if there is no link multiplicity
          link_name <- links[['name']][!is.na(links[['name']])]
          backref <- links[['backref']][!is.na(links[['name']])]
          label <- links[['label']][!is.na(links[['name']])]
          target <- links[['target_type']][!is.na(links[['name']])]
          multiplicity <- links[['multiplicity']][!is.na(links[['name']])]
          link_required <- links[['required']][!is.na(links[['name']])]
      } else if ('subgroup' %in% names(links)) {
          link_name <- links$subgroup[[1]][['name']]
          backref <- links$subgroup[[1]][['backref']] 
          label <- links$subgroup[[1]][['label']] 
          target <- links$subgroup[[1]][['target_type']] 
          multiplicity <- links$subgroup[[1]][['multiplicity']]
          link_required <- links$subgroup[[1]][['required']]
      } else {
          link_name <- NA
          backref <- NA
          label <- NA
          target <- NA
          multiplicity <- NA
          link_required <- NA
      }

      links_list <- tryCatch(
        {
          links_list <- data.frame(NODE = node$id,
                                   TITLE = node$title,
                                   CATEGORY = node$category,
                                   DESCRIPTION = node$description,
                                   LINK_NAME = link_name,
                                   BACKREF = backref,
                                   LABEL = label,
                                   TARGET = target,
                                   MULTIPLICITY = multiplicity, 
                                   LINK_REQUIRED = link_required)
        },
        error=function(cond) {
          message(paste("Skipping creation of table row ", node$title))
          message('')
        },
        warning=function(cond) {
          message(paste("Warning created: ", node$title))
        }
      )       
      
      if(inherits(links_list, "error")) next
      
      compendium_nodes <- rbind(compendium_nodes, links_list)
      
      ## Get variables and append to compendium df
      
      NODE <- node$id
      # get list of variables
      fields <- node$properties
      linktoremove <- unlist(node$links)[grepl("name", names(unlist(node$links)))]
      fieldnames <- names(fields) 
      ref <- fields$`$ref`
      
      # check nested props in ref
      if(!is.null(ref)){
        for(r in ref){
          reference <- strsplit(r,"#/")[[1]]
          reffile <- reference[1]
          if(reffile %in% names(dictionary$helper_yaml)){
              nested <- dictionary$helper_yaml[[reffile]]
          }
          else{
              nested <- dictionary$node_list[[reffile]]
          }
          
          nested_fields <- names(nested[[reference[2]]])
          for (f in nested_fields){
            field <- nested[[reference[2]]][[f]]
            if('$ref' %in% names(field)){
              fields[[f]] <- nested[[f]]
            }
            else{
              fields[[f]] <- field
            }
          }
          fieldnames <- c(fieldnames, nested_fields)
        }
      }

      #don't include $ref and other internal variables #PROVISIONALLY HARD CODED
      excluded_fields <- c("$ref", "type", "error_type", "state", "id",
                           "file_state", "created_datetime", "updated_datetime",
                           "state", "state_comment", "project_id", "submitter_id",
                           "workflow_start_datetime", "workflow_end_datetime", 
                           "sequencing_date", "run_datetime")
      fieldnames <- fieldnames[!fieldnames %in% linktoremove]
      fieldnames <- fieldnames[!(fieldnames %in% excluded_fields)]
      required <- node$required            
 
      # loop through fields in node to get variables
      for (f in fieldnames) {
        if ("$ref" %in% names(fields[[f]])){ 
          if ('type' %in% names(fields[[f]]) | 'enum' %in% names(fields[[f]])) next
          else {
            
            # Check nested property
            ref <- fields[[f]]$`$ref`
            reference <- strsplit(ref,"#/")[[1]]
            reffile <- reference[1]
            property <- reference[2]
            if (grepl("/", property) > 0){
              property <- strsplit(property,"/")[[1]]
              definitions <- dictionary$node_list[[reffile]]
            }
            else{
              definitions <- dictionary$helper_yaml[[reffile]]
            }
                        
            if (length(property) > 1){
              fields[[f]] <- definitions[[property[1]]][[property[2]]] 
            }
            else{
              fields[[f]] <- definitions[[property]]
            }
          }
        }
        
        if ('description' %in% names(fields[[f]])) {
          DESCRIPTION = fields[[f]]$description
        } else {
          DESCRIPTION = paste0("See : ", fields[[f]]$term$`$ref`)
        }
        
        if ('enum' %in% names(fields[[f]])) {
          TYPE <- 'enum'
          elements <- fields[[f]]$enum
          CHOICES <- paste(elements, collapse='|')
          TEMPCHOICES <- length(elements)
          MAX <- NA
          MIN <- NA                
        } else {
          if ('type' %in% names(fields[[f]])){    
            TYPE <- fields[[f]]$type[1]
          }              
          else if ('oneOf' %in% names(fields[[f]])){
            TYPE <- fields[[f]]$oneOf$type[1]
          }
          CHOICES <- ''
          if ('pattern' %in% names(fields[[f]])){
            CHOICES <- fields[[f]]$pattern[1]
          }
          TEMPCHOICES <- 0
          MAX <- NA
          MIN <- NA
          if ('maximum' %in% names(fields[[f]])){
            MAX <- fields[[f]]$maximum
          }
          if ('minimum' %in% names(fields[[f]])){
            MIN <- fields[[f]]$minimum
          }                
        }
        
        if (f %in% required) {
          REQUIRED <- TRUE
        } else {
          REQUIRED <- FALSE
        }
        
        var_list <- tryCatch(
          {
            var_list <- data.frame(
              DESCRIPTION = DESCRIPTION,
              NODE = NODE,
              VARIABLE = paste0(f, ".", NODE),
              REQUIRED = REQUIRED,
              TYPE = TYPE,
              CHOICES = CHOICES,
              TEMPCHOICES = TEMPCHOICES,
              MAX = MAX,
              MIN = MIN)
          },
          error=function(cond) {
            message(paste("Error creating variable ", f, " on node ", node$id))
            message(cond)
            message('')
          },
          warning=function(cond) {
            message(paste("Warning created: ", f))
          }                
        ) 
        
        compendium <- rbind(compendium, var_list)
      }      
  }

  ## Add sim values to compendium
  getEnumProbs <- function(df){
    probs <- c()
    for(i in 1:nrow(df)) {
      row <- df[i,]
      num <- row[['TEMPCHOICES']]
      if (num == '') {probs_new = ''} else {
        probs_new <- paste(rep(1/num, num), collapse='|')
        probs <- c(probs, probs_new)
      }
    }
    return(probs)
  }
  compendium$DESCRIPTION <- as.character(compendium$DESCRIPTION)
  compendium$NODE <- as.character(compendium$NODE)
  compendium$VARIABLE <- as.character(compendium$VARIABLE)
  compendium$CHOICES <- as.character(compendium$CHOICES)
  compendium$TYPE <- as.character(compendium$TYPE)
  
  compendium$PROBS <- getEnumProbs(compendium)
  compendium$PROBS[compendium$TYPE=='boolean'] <- c('.4|.6')
  compendium$TEMPCHOICES <- NULL
  
  compendium$DISTRIB <- ''
  compendium$DISTRIB[compendium$TYPE=='integer'] <- 'poisson'
  compendium$DISTRIB[compendium$TYPE=='number'] <- 'normal'
  
  compendium$DISTRIB.INPUTS <- ''
  compendium$DISTRIB.INPUTS[compendium$TYPE=='integer'] <- 'lambda = 4'
  compendium$DISTRIB.INPUTS[compendium$TYPE=='number'] <- 'mean = 10, sd = 3'
  
  # update number/integer distribution if a range is provided
  means <- (compendium$MAX[compendium$TYPE=='integer' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='integer' &!is.na(compendium$MIN)]) / 2         
  compendium$DISTRIB.INPUTS[compendium$TYPE=='integer' & !is.na(compendium$MIN)] <- paste("lambda = ", as.character(means), sep="")
  means <- (compendium$MAX[compendium$TYPE=='number' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='number' &!is.na(compendium$MIN)]) / 2         
  compendium$DISTRIB.INPUTS[compendium$TYPE=='number' & !is.na(compendium$MIN)] <- paste("mean = ", as.character(means), ", sd = 10", sep="")
  
  
  compendium$NAS <- runif(nrow(compendium), 0, .2)
  compendium$POSITIVEONLY <- ''
  
  # create final object with compendium and compendium node relationships
  compendium_objects <- list(compendium = compendium,
                             compendium_nodes = compendium_nodes)
  return(compendium_objects)  
    
}

simFromDictionary <- function(dictionary, branch, project_name, required_only=F, n, output_to_json=F, dir=NULL) {
  # given the raw dictionary, build a base compendium table
  # and a node relationship table and run simulation
  #
  # Args:
  #   dictionary: dictionary repo name, eg: 'bpadictionary'
  #   branch: branch name to use for desired dictionary  
  #   required_only: to subset compendium so that only required fields are simmed
  #   n: number of sims for each variable
  #   output_to_json:  create output json files
  #   dir: output for json files
  #
  # Returns:
  #   simdata and json files in output directory
  
  print("Loading Simulation Tools...")
  source('https://raw.githubusercontent.com/occ-data/data-simulator/master/SimtoJson.R')
  source('https://raw.githubusercontent.com/occ-data/data-simulator/master/SimData.R')
  
  print("Getting JSON form dictionary...") 
  dictionary <- readDictionary(repo, branch)
  
  print("Creating Compendium and Node Relationship Table...")
  compendiumObjects <- buildCompendiums(dictionary)
  compendium <- compendiumObjects$compendium
  
  if (required_only) {
    compendium <- compendium[compendium$REQUIRED==TRUE,]
  } 
  
  print("Simulating Data...")
  simdata <- simData(compendium, 
                     n, 
                     include.na = FALSE, 
                     reject= FALSE)
  
  if (output_to_json) {
    print("Generating Json...")
    SimtoJson(simdata, 
              compendium, 
              compendiumObjects$compendium_nodes,
              project_name,
              dir)
  }
  
  return(simdata)
  
}

## Run Example: 
#repo <- 'https://github.com/occ-data/bpadictionary'
#repo <- 'https://github.com/NCI-GDC/gdcdictionary'
#branch <- 'develop'
#n <- 1
#dir <- 'SampleFullDictionaryJsonOutput/'
#finalSim <- simFromDictionary(repo, branch, required_only=F, n, output_to_json=T, dir)
