
if(!require(yaml)) install.packages(yaml)
if(!require(httr)) install.packages(httr)

## PROJECT OUTLINE
# 1:  go through repo, get raw urls associated with each node
# 2:  go through each node and extract the details matching with 
##      compendium and link dfs required for submission
# 3:  for compendium, create functions that create random stats 
##      properties for each variable type
# 4:  given compendium and links, sim.
# optional:  flag for required, flag to create multiple 
##    entries on lower level nodes

#https://stackoverflow.com/questions/25485216/how-to-get-list-files-from-a-github-repository-folder-using-r

# Helper  
readDictionary <- function(repo, branch) {
    # given github repo, get list of links for each dictionary yaml
    #
    # Args:
    #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
    #   branch: branch name to use for desired dictionary
    #
    # Returns:
    #   dictionary_nodes:  R object with two lists: 
    #      nodelist: location for all yaml representing dictionary nodes
    #      alt_yaml:  location for all yaml representing persistent definitions, settings and terms
    
    # prep links
    root <- gsub('https://github.com', '', repo)
    api_call <- paste0('https://api.github.com/repos', root, '/git/trees/', branch, '?recursive=1')
    
    # get directory then node names
    directory <- GET(api_call)
    filelist <- unlist(lapply(content(directory)$tree, "[", "path"), use.names = F)
    filelist <- grep("/schemas/", filelist, value = TRUE, fixed = TRUE)
    filelist <- grep(".yaml", filelist, value = TRUE, fixed = TRUE)
    
    # get dictionary nodes and dictionary helpers
    ## filter out exceptions
    altdefs <- grep("/_", filelist, value = TRUE, fixed = TRUE)
    metaschema <- grep("/metaschema.yaml", filelist, value = TRUE, fixed = TRUE)
    program <- grep("/program.yaml", filelist, value = TRUE, fixed = TRUE)
    project <- grep("/project.yaml", filelist, value = TRUE, fixed = TRUE)
    other <- grep("/projects/", filelist, value = TRUE, fixed = TRUE)
    altdefs <- c(altdefs, metaschema, program, project, other)
    nodelist <- filelist[!filelist %in% altdefs]
    
    getNodeURL <- function(node_loc, repo, branch) {
        # given a node name/location, return url to get yaml
        #
        # Args:
        #   node_loc: location in repo of file
        #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
        #   branch: branch name to use for desired dictionary
        #
        # Returns:
        #   rawURL: URL to GET node yaml
        
        root <- gsub('https://github.com', '', repo)
        rawURL <- paste0('https://raw.githubusercontent.com', root, '/', branch, '/', node_loc)
        return(rawURL)
    }
    
    altdefs <- sapply(altdefs, getNodeURL, repo=repo, branch=branch)
    nodelist <- sapply(nodelist, getNodeURL, repo=repo, branch=branch)
    
    dictionary_nodes <- list(node_list = nodelist,
                             helper_yaml = altdefs)
    return(dictionary_nodes)

}

## Create Node_Compendium and Compendium from Dictionary

buildCompendiums <- function(dictionary) {
    # given the raw dictionary, build a base compendium table
    # and a node relationship table to prep for simulation
    #
    # Args:
    #   dictionary: list of node links generated by the readDictionary 
    #       function
    #
    # Returns:
    #   compendiums_objects:  R object with two lists: 
    #      compendium: representing all variables in the dictionary
    #      compendium_nodes:  representing the relationship between 
    #        nodes in the dictionary
    
    # initialize empty DFs to store objects
    compendium_nodes <- data.frame(NODE = character(), 
                                   TITLE = character(),
                                   CATEGORY = character(),
                                   DESCRIPTION = character(),
                                   LINK_NAME = character(),
                                   BACKREF = character(),
                                   LABEL = character(),
                                   TARGET = character(),
                                   MULTIPLICITY = character(), 
                                   LINK_REQUIRED = character()) 
    compendium <- data.frame(DESCRIPTION = character(),
                             NODE = character(),
                             VARIABLE = character(),
                             REQUIRED = logical(), 
                             TYPE = character(),
                             CHOICES = character(), 
                             TEMPCHOICES = numeric())
    
    # get objects from dictionary
    node_list <- dictionary$node_list
    
    # loop through nodes
    for (n in node_list) {
        
        #error handling for if issues with source .yaml
        node <- tryCatch(
            {
                node <- yaml.load_file(n)
            },
            error=function(cond) {
                message(paste("Error loading:", n))
                message(cond)
                message('')
            },
            warning=function(cond) {
                message(paste("Warning created:", n))
                message(cond)
                message('')
            }
        )  
        
        if(inherits(node, "error")) next
        
        links <- unlist(node$links)
        # get compendium_nodes field definitions
        if ('name' %in% names(links)) {
            # if there is no link multiplicity
            link_name <- links[['name']]
            backref <- links[['backref']]
            label <- links[['label']]
            target <- links[['target_type']]
            multiplicity <- links[['multiplicity']]
            link_required <- links[['required']]
        } else if ('subgroup.name' %in% names(links)) {
            link_name <- links[['subgroup.name']]
            backref <- links[['subgroup.backref']]
            label <- links[['subgroup.label']]
            target <- links[['subgroup.target_type']]
            multiplicity <- links[['subgroup.multiplicity']]
            link_required <- links[['subgroup.required']]
        } else {
            link_name <- NA
            backref <- NA
            label <- NA
            target <- NA
            multiplicity <- NA
            link_required <- NA
        }
        
        links_list <- tryCatch(
            {
                links_list <- data.frame(NODE = node$id,
                                         TITLE = node$title,
                                         CATEGORY = node$category,
                                         DESCRIPTION = node$description,
                                         LINK_NAME = link_name,
                                         BACKREF = backref,
                                         LABEL = label,
                                         TARGET = target,
                                         MULTIPLICITY = multiplicity, 
                                         LINK_REQUIRED = link_required)
            },
            error=function(cond) {
                message(paste("Error creating table row ", node$title))
                message('')
            },
            warning=function(cond) {
                message(paste("Warning created: ", node$title))
            }
        )  
        
        if(inherits(links_list, "error")) next

        compendium_nodes <- rbind(compendium_nodes, links_list)
        
        NODE <- node$id
        # need to extract description, variable, required, type, and choices from below info
        fields <- node$properties
        linktoremove <- unlist(node$links)[grepl("name", names(unlist(node$links)))]
        fieldnames <- names(fields) #don't include $ref
        fieldnames <- fieldnames[!fieldnames %in% linktoremove]
        fieldnames <- fieldnames[!fieldnames %in% "$ref"]
        ref <- fields$`$ref`
        required <- node$required
        
        for (f in fieldnames) {
            
            if ("$ref" %in% names(fields[[f]])) next
            
            if ('description' %in% names(fields[[f]])) {
                DESCRIPTION = fields[[f]]$description
            } else {
                DESCRIPTION = paste0("See : ", fields[[f]]$term$`$ref`)
            }
            
            if ('enum' %in% names(fields[[f]])) {
                TYPE <- 'enum'
                elements <- fields[[f]]$enum
                CHOICES <- paste(elements, collapse='|')
                TEMPCHOICES <- length(elements)
            } else {
                TYPE <- fields[[f]]$type[1]
                CHOICES <- ''
                TEMPCHOICES <- 0
            }
            
            if (f %in% required) {
                REQUIRED <- TRUE
            } else {
                REQUIRED <- FALSE
            }
            
            var_list <- tryCatch(
                {
                    var_list <- data.frame(
                        DESCRIPTION = DESCRIPTION,
                        NODE = NODE,
                        VARIABLE = f,
                        REQUIRED = REQUIRED,
                        TYPE = TYPE,
                        CHOICES = CHOICES,
                        TEMPCHOICES = TEMPCHOICES)
                },
                error=function(cond) {
                    message(paste("Error creating variable ", f, " on node ", node$id))
                    message(cond)
                    message('')
                },
                warning=function(cond) {
                    message(paste("Warning created: ", f))
                }
            ) 
            
            compendium <- rbind(compendium, var_list)
        }
    }
    
    compendium_objects <- list(compendium = compendium,
                               compendium_nodes = compendium_nodes)
    return(compendium_objects)
}

## Run Example: 
#repo <- 'https://github.com/occ-data/bpadictionary'
#repo <- 'https://github.com/NCI-GDC/gdcdictionary'
#branch <- 'develop'

#get urls for nodes
#dictionary <- readDictionary(repo, branch)
#testObject <- buildCompendiums(dictionary)




