
if(!require(yaml)) install.packages(yaml)
if(!require(httr)) install.packages(httr)

## PROJECT OUTLINE
# 1:  go through repo, get raw urls associated with each node
# 2:  go through each node and extract the details matching with 
##      compendium and link dfs required for submission
# 3:  for compendium, create functions that create random stats 
##      properties for each variable type
# 4:  given compendium and links, sim.
# optional:  flag for required, flag to create multiple 
##    entries on lower level nodes

#https://stackoverflow.com/questions/25485216/how-to-get-list-files-from-a-github-repository-folder-using-r

# Helper  
readDictionary <- function(repo, branch) {
    # given github repo, get list of links for each dictionary yaml
    #
    # Args:
    #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
    #   branch: branch name to use for desired dictionary
    #
    # Returns:
    #   dictionary_nodes:  R object with two lists: 
    #      nodelist: location for all yaml representing dictionary nodes
    #      alt_yaml:  location for all yaml representing persistent definitions, settings and terms
    
    # prep links
    root <- gsub('https://github.com', '', repo)
    api_call <- paste0('https://api.github.com/repos', root, '/git/trees/', branch, '?recursive=1')
    
    # get directory then node names
    directory <- GET(api_call)
    filelist <- unlist(lapply(content(directory)$tree, "[", "path"), use.names = F)
    filelist <- grep("/schemas/", filelist, value = TRUE, fixed = TRUE)
    filelist <- grep(".yaml", filelist, value = TRUE, fixed = TRUE)
    
    # get dictionary nodes and dictionary helpers
    ## filter out exceptions
    altdefs <- grep("/_", filelist, value = TRUE, fixed = TRUE)
    metaschema <- grep("/metaschema.yaml", filelist, value = TRUE, fixed = TRUE)
    program <- grep("/program.yaml", filelist, value = TRUE, fixed = TRUE)
    project <- grep("/project.yaml", filelist, value = TRUE, fixed = TRUE)
    other <- grep("/projects/", filelist, value = TRUE, fixed = TRUE)
    altdefs <- c(altdefs, metaschema, program, project, other)
    nodelist <- filelist[!filelist %in% altdefs]
    
    getNodeURL <- function(node_loc, repo, branch) {
        # given a node name/location, return url to get yaml
        #
        # Args:
        #   node_loc: location in repo of file
        #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
        #   branch: branch name to use for desired dictionary
        #
        # Returns:
        #   rawURL: URL to GET node yaml
        
        root <- gsub('https://github.com', '', repo)
        rawURL <- paste0('https://raw.githubusercontent.com', root, '/', branch, '/', node_loc)
        return(rawURL)
    }
    
    altdefs <- sapply(altdefs, getNodeURL, repo=repo, branch=branch)
    nodelist <- sapply(nodelist, getNodeURL, repo=repo, branch=branch)
    
    dictionary_nodes <- list(node_list = nodelist,
                             helper_yaml = altdefs)
    return(dictionary_nodes)

}



## Run Example: 
#repo <- 'https://github.com/occ-data/bpadictionary'
repo <- 'https://github.com/NCI-GDC/gdcdictionary'
branch <- 'develop'
dictionary <- readDictionary(repo, branch)

node_loc <- dictionary$node_list[3]

# sample single node for below
node <- yaml.load_file(node_loc)

## Create Node_Compendium and Compendium from Dictionary

buildCompendiums <- function(dictionary) {
    # given the raw dictionary, build a base compendium table
    # and a node relationship table to prep for simulation
    #
    # Args:
    #   dictionary: list of node links generated by the readDictionary 
    #       function
    #
    # Returns:
    #   compendiums_objects:  R object with two lists: 
    #      compendium: representing all variables in the dictionary
    #      compendium_nodes:  representing the relationship between 
    #        nodes in the dictionary
    
    # initialize empty DFs to store objects
    compendium_nodes <- data.frame(NODE = character(), 
                                   TITLE = character(),
                                   CATEGORY = character(),
                                   DESCRIPTION = character(),
                                   LINK_NAME = character(),
                                   BACKREF = character(),
                                   LABEL = character(),
                                   TARGET = character(),
                                   MULTIPLICITY = character(), 
                                   LINK_REQUIRED = character()) 
    compendium <- data.frame(DESCRIPTION = character(),
                             NODE = character(),
                             VARIABLE = character(),
                             REQUIRED = logical(), 
                             TYPE = character(),
                             CHOICES = character(), 
                             TEMPCHOICES = numeric())
    
    # get objects from dictionary
    #node_list <- dictionary$node_list
    
    # testing
    node_list <- c('https://raw.githubusercontent.com/occ-data/bpadictionary/develop/gdcdictionary/schemas/read_group_qc.yaml', 
                   'https://raw.githubusercontent.com/occ-data/bpadictionary/develop/gdcdictionary/schemas/demographic.yaml', 
                   'https://raw.githubusercontent.com/NCI-GDC/gdcdictionary/develop/gdcdictionary/schemas/aligned_reads.yaml')
    
    # loop through nodes
    for (n in node_list) {
        # get single node
        node <- yaml.load_file(n)
        
        
        # new exception:
        # https://github.com/NCI-GDC/gdcdictionary/blob/develop/gdcdictionary/schemas/aligned_reads.yaml
        links <- unlist(node$links)
        # get compendium_nodes field definitions
        if ('name' %in% names(links)) {
            # if there is no link multiplicity
            link_name <- links[['name']]
            backref <- links[['backref']]
            label <- links[['label']]
            target <- links[['target_type']]
            multiplicity <- links[['multiplicity']]
            link_required <- links[['required']]
        } else {
            link_name <- links[['subgroup.name']]
            backref <- links[['subgroup.backref']]
            label <- links[['subgroup.label']]
            target <- links[['subgroup.target_type']]
            multiplicity <- links[['subgroup.multiplicity']]
            link_required <- links[['subgroup.required']]
        }
        
        links_list <- data.frame(NODE = node$id,
                           TITLE = node$title,
                           CATEGORY = node$category,
                           DESCRIPTION = node$description,
                           LINK_NAME = link_name,
                           BACKREF = backref,
                           LABEL = label,
                           TARGET = target,
                           MULTIPLICITY = multiplicity, 
                           LINK_REQUIRED = link_required)
        
        compendium_nodes <- rbind(compendium_nodes, links_list)
        
        ## get compendium field definitions
    }
    
    compendium_objects <- list(compendium = compendium,
                               compendium_nodes = compendium_nodes)
    return(compendium_objects)
}


## compendium df
#model after : https://github.com/occ-data/data-simulator/blob/master/SampleCompendium/sampleClinical.csv
NODE <- node$id

# need to extract description, variable, required, type, and choices from below info
fields <- node$properties
linkback <- node$links[[1]]$name
fieldnames <- names(fields)[-1] #don't include $ref
fieldnames <- fieldnames[!fieldnames %in% linkback]
ref <- fields$`$ref`
required <- node$required

for (f in fieldnames) {
    
    if ('description' %in% names(fields[[f]])) {
        DESCRIPTION = fields[[f]]$description
    } else {
        DESCRIPTION = paste0("See : ", fields[[f]]$term$`$ref`)
    }
    
    if ('enum' %in% names(fields[[f]])) {
        TYPE <- 'enum'
        elements <- fields[[f]]$enum
        CHOICES <- paste(elements, collapse='|')
        TEMPCHOICES <- length(elements)
    } else {
        TYPE <- fields[[f]]$type[1]
        CHOICES <- ''
        TEMPCHOICES <- 0
    }
    
    if (f %in% required) {
        REQUIRED <- TRUE
    } else {
        REQUIRED <- FALSE
    }
    
    var_list <- data.frame(
        DESCRIPTION = DESCRIPTION,
        NODE = NODE,
        VARIABLE = f,
        REQUIRED = REQUIRED,
        TYPE = TYPE,
        CHOICES = CHOICES,
        TEMPCHOICES = TEMPCHOICES
    )
    compendium <- rbind(compendium, var_list)
}



